#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
#include <iomanip>
#include <optional>
#include <algorithm>
#include "json.hpp"

using json = nlohmann::json;

// ------------------ Constants ------------------
const double HORIZONTAL_THRESHOLD = 0.9;
const double PI = M_PI;

// ------------------ Utility Functions ------------------

double signed_volume(const std::vector<double>& a,
                     const std::vector<double>& b,
                     const std::vector<double>& c,
                     const std::vector<double>& d) {
    double ax = a[0] - d[0], ay = a[1] - d[1], az = a[2] - d[2];
    double bx = b[0] - d[0], by = b[1] - d[1], bz = b[2] - d[2];
    double cx = c[0] - d[0], cy = c[1] - d[1], cz = c[2] - d[2];
    return (ax * (by * cz - bz * cy) - ay * (bx * cz - bz * cx) + az * (bx * cy - by * cx)) / 6.0;
}

std::vector<double> get_point(const json& j, int idx) {
    std::vector<int> vi = j["vertices"][idx];
    double x = vi[0] * j["transform"]["scale"][0].get<double>() + j["transform"]["translate"][0].get<double>();
    double y = vi[1] * j["transform"]["scale"][1].get<double>() + j["transform"]["translate"][1].get<double>();
    double z = vi[2] * j["transform"]["scale"][2].get<double>() + j["transform"]["translate"][2].get<double>();
    return {x, y, z};
}

// Compute surface normal using cross product for triangles or Newell's method for polygons
std::optional<std::vector<double>> compute_normal(const std::vector<std::vector<double>>& pts) {
    if (pts.size() < 3) return std::nullopt;

    if (pts.size() == 3) {
        // Triangle: use cross product
        std::vector<double> u(3), v(3);
        for (int i = 0; i < 3; ++i) {
            u[i] = pts[1][i] - pts[0][i];
            v[i] = pts[2][i] - pts[0][i];
        }
        std::vector<double> n = {
                u[1] * v[2] - u[2] * v[1],
                u[2] * v[0] - u[0] * v[2],
                u[0] * v[1] - u[1] * v[0]
        };
        double len = std::sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]);
        if (len == 0) return std::nullopt;
        return std::vector<double>{n[0]/len, n[1]/len, n[2]/len};
    } else {
        // Polygon: use Newell's method
        double nx = 0, ny = 0, nz = 0;
        for (size_t i = 0; i < pts.size(); ++i) {
            const auto& current = pts[i];
            const auto& next = pts[(i + 1) % pts.size()];
            nx += (current[1] - next[1]) * (current[2] + next[2]);
            ny += (current[2] - next[2]) * (current[0] + next[0]);
            nz += (current[0] - next[0]) * (current[1] + next[1]);
        }
        double norm = std::sqrt(nx * nx + ny * ny + nz * nz);
        if (norm == 0) return std::nullopt;
        return std::vector<double>{nx / norm, ny / norm, nz / norm};
    }
}

// Check if surface is horizontal based on Z-component of normal
bool is_horizontal(const std::vector<double>& normal) {
    return std::abs(normal[2]) > HORIZONTAL_THRESHOLD;
}

// Calculate azimuth angle from normal vector
double azimuth_from_normal(const std::vector<double>& normal) {
    double x = normal[0], y = normal[1];
    double angle_rad = std::atan2(x, y);
    double angle_deg = angle_rad * 180.0 / PI;
    return (angle_deg < 0) ? angle_deg + 360.0 : angle_deg;
}

// Map azimuth to compass direction
std::string azimuth_to_direction(double azimuth) {
    // Normalize azimuth to [0, 360) range
    while (azimuth < 0) azimuth += 360.0;
    while (azimuth >= 360.0) azimuth -= 360.0;

    if (azimuth >= 337.5 || azimuth < 22.5) return "N";
    else if (azimuth >= 22.5 && azimuth < 67.5) return "NE";
    else if (azimuth >= 67.5 && azimuth < 112.5) return "E";
    else if (azimuth >= 112.5 && azimuth < 157.5) return "SE";
    else if (azimuth >= 157.5 && azimuth < 202.5) return "S";
    else if (azimuth >= 202.5 && azimuth < 247.5) return "SW";
    else if (azimuth >= 247.5 && azimuth < 292.5) return "W";
    else if (azimuth >= 292.5 && azimuth < 337.5) return "NW";
    else return "N"; // fallback
}

// Calculate polygon area using shoelace formula
double calculate_polygon_area(const std::vector<std::vector<double>>& pts) {
    if (pts.size() < 3) return 0.0;

    double area = 0.0;
    for (size_t i = 0; i < pts.size(); ++i) {
        size_t j = (i + 1) % pts.size();
        area += pts[i][0] * pts[j][1] - pts[j][0] * pts[i][1];
    }
    return std::abs(area) * 0.5;
}

// Calculate 3D polygon area using cross product method
double calculate_3d_polygon_area(const std::vector<std::vector<double>>& pts) {
    if (pts.size() < 3) return 0.0;

    std::vector<double> total_cross = {0.0, 0.0, 0.0};

    for (size_t i = 1; i < pts.size() - 1; ++i) {
        std::vector<double> v1 = {
                pts[i][0] - pts[0][0],
                pts[i][1] - pts[0][1],
                pts[i][2] - pts[0][2]
        };
        std::vector<double> v2 = {
                pts[i+1][0] - pts[0][0],
                pts[i+1][1] - pts[0][1],
                pts[i+1][2] - pts[0][2]
        };

        // Cross product
        total_cross[0] += v1[1] * v2[2] - v1[2] * v2[1];
        total_cross[1] += v1[2] * v2[0] - v1[0] * v2[2];
        total_cross[2] += v1[0] * v2[1] - v1[1] * v2[0];
    }

    double magnitude = std::sqrt(
            total_cross[0] * total_cross[0] +
            total_cross[1] * total_cross[1] +
            total_cross[2] * total_cross[2]
    );

    return magnitude * 0.5;
}

// ------------------ Introspection Helpers ------------------

int get_no_roof_surfaces(json &j) {
    int total = 0;
    for (auto& co : j["CityObjects"].items()) {
        for (auto& g : co.value()["geometry"]) {
            if (g["type"] == "Solid") {
                for (auto& shell : g["semantics"]["values"]) {
                    for (auto& s : shell) {
                        if (g["semantics"]["surfaces"][s.get<int>()]["type"].get<std::string>() == "RoofSurface") {
                            total++;
                        }
                    }
                }
            }
        }
    }
    return total;
}

void visit_roofsurfaces(json &j) {
    for (auto& co : j["CityObjects"].items()) {
        for (auto& g : co.value()["geometry"]) {
            if (g["type"] == "Solid") {
                for (int i = 0; i < g["boundaries"].size(); i++) {
                    for (int j = 0; j < g["boundaries"][i].size(); j++) {
                        int sem_index = g["semantics"]["values"][i][j];
                        if (g["semantics"]["surfaces"][sem_index]["type"].get<std::string>() == "RoofSurface") {
                            std::cout << "RoofSurface: " << g["boundaries"][i][j] << std::endl;
                        }
                    }
                }
            }
        }
    }
}

void list_all_vertices(const json& j) {
    for (const auto& co : j["CityObjects"].items()) {
        std::cout << "= CityObject: " << co.key() << std::endl;
        for (const auto& g : co.value()["geometry"]) {
            if (g["type"] == "Solid") {
                for (const auto& shell : g["boundaries"]) {
                    for (const auto& surface : shell) {
                        for (const auto& ring : surface) {
                            std::cout << "---" << std::endl;
                            for (const auto& v : ring) {
                                std::vector<int> vi = j["vertices"][v.get<int>()];
                                double x = vi[0] * j["transform"]["scale"][0].get<double>() + j["transform"]["translate"][0].get<double>();
                                double y = vi[1] * j["transform"]["scale"][1].get<double>() + j["transform"]["translate"][1].get<double>();
                                double z = vi[2] * j["transform"]["scale"][2].get<double>() + j["transform"]["translate"][2].get<double>();
                                std::cout << std::setprecision(2) << std::fixed << v << " (" << x << ", " << y << ", " << z << ")" << std::endl;
                            }
                        }
                    }
                }
            }
        }
    }
}

// ------------------ Main Processing Functions ------------------

void process_roof_surfaces(json& j) {
    int processed_surfaces = 0;

    std::cout << "\n=== Processing RoofSurfaces for Orientation and Area ===" << std::endl;

    for (auto& [obj_id, co] : j["CityObjects"].items()) {
        for (auto& geom : co["geometry"]) {
            if (geom["type"] != "Solid") continue;

            // Process each shell
            for (size_t shell_idx = 0; shell_idx < geom["boundaries"].size(); ++shell_idx) {
                const auto& shell = geom["boundaries"][shell_idx];
                const auto& semantics = geom["semantics"]["values"][shell_idx];

                // Process each surface in the shell
                for (size_t surf_idx = 0; surf_idx < shell.size(); ++surf_idx) {
                    const auto& surface = shell[surf_idx];
                    int sem_index = semantics[surf_idx].get<int>();

                    // Check if this is a RoofSurface
                    if (geom["semantics"]["surfaces"][sem_index]["type"].get<std::string>() != "RoofSurface") {
                        continue;
                    }

                    processed_surfaces++;
                    std::cout << "Processing RoofSurface #" << processed_surfaces
                              << " in object: " << obj_id << std::endl;

                    // Process each ring of the surface (typically just the outer ring)
                    for (const auto& ring : surface) {
                        if (ring.size() < 3) continue;

                        // Get the actual 3D coordinates
                        std::vector<std::vector<double>> pts;
                        for (int idx : ring) {
                            pts.push_back(get_point(j, idx));
                        }

                        // Calculate surface normal
                        auto maybe_normal = compute_normal(pts);
                        if (!maybe_normal.has_value()) {
                            std::cout << "  Warning: Could not compute normal for surface" << std::endl;
                            continue;
                        }

                        std::vector<double> normal = maybe_normal.value();
                        std::cout << "  Normal vector: (" << normal[0] << ", "
                                  << normal[1] << ", " << normal[2] << ")" << std::endl;

                        // Determine orientation
                        std::string orientation;
                        if (is_horizontal(normal)) {
                            orientation = "horizontal";
                        } else {
                            double azimuth = azimuth_from_normal(normal);
                            orientation = azimuth_to_direction(azimuth);
                            std::cout << "  Azimuth: " << std::fixed << std::setprecision(1)
                                      << azimuth << " degrees" << std::endl;
                        }

                        std::cout << "  Orientation: " << orientation << std::endl;

                        // Calculate area
                        double area = calculate_3d_polygon_area(pts);
                        std::cout << "  Area: " << std::fixed << std::setprecision(2)
                                  << area << " square units" << std::endl;

                        // Add orientation and area to the semantic surface
                        geom["semantics"]["surfaces"][sem_index]["orientation"] = orientation;
                        geom["semantics"]["surfaces"][sem_index]["area"] = area;

                        std::cout << "  Updated semantic surface with orientation and area" << std::endl;

                        // Only process the first (outer) ring for now
                        break;
                    }
                }
            }
        }
    }

    std::cout << "\nTotal RoofSurfaces processed: " << processed_surfaces << std::endl;
}

// ------------------ Main Function ------------------

int main(int argc, const char* argv[]) {
    const char* filename = (argc > 1) ? argv[1] : "10-282-562.city.json";
    std::cout << "Processing: " << filename << std::endl;

    // Read input file
    std::ifstream input(filename);
    if (!input.is_open()) {
        std::cerr << "Error: Could not open file " << filename << std::endl;
        return 1;
    }

    json j;
    try {
        input >> j;
    } catch (const std::exception& e) {
        std::cerr << "Error parsing JSON: " << e.what() << std::endl;
        return 1;
    }
    input.close();

    std::cout << "Total RoofSurfaces found: " << get_no_roof_surfaces(j) << std::endl;

    // Process roof surfaces for orientation and area
    process_roof_surfaces(j);

    // Additional processing (volume calculation, etc.)
    std::vector<double> fake_point = {0.0, 0.0, -1000.0};
    int nobuildings = 0;

    for (auto& [id, co] : j["CityObjects"].items()) {
        if (co["type"] != "Building") continue;

        double total_volume = 0.0;
        int total_tetrahedra = 0;
        std::vector<std::vector<double>> roof_normals;

        std::cout << "\nDecomposing building: " << id << std::endl;

        if (!co.contains("children")) continue;
        for (const auto& child_id : co["children"]) {
            const auto& child = j["CityObjects"][child_id.get<std::string>()];
            for (const auto& geom : child["geometry"]) {
                if (geom["type"] != "Solid" || geom["lod"] != "2.2") continue;

                for (size_t i = 0; i < geom["boundaries"].size(); ++i) {
                    const auto& shell = geom["boundaries"][i];
                    const auto& semantics = geom["semantics"]["values"][i];

                    for (size_t j_idx = 0; j_idx < shell.size(); ++j_idx) {
                        const auto& surface = shell[j_idx];
                        int sem_index = semantics[j_idx].get<int>();
                        std::string sem_type = geom["semantics"]["surfaces"][sem_index]["type"];

                        for (const auto& ring : surface) {
                            if (ring.size() < 3) continue;

                            std::vector<std::vector<double>> pts;
                            for (int idx : ring) {
                                pts.push_back(get_point(j, idx));
                            }

                            if (sem_type == "RoofSurface") {
                                auto maybe_normal = compute_normal(pts);
                                if (maybe_normal.has_value()) {
                                    roof_normals.push_back(maybe_normal.value());
                                }
                            }

                            for (size_t i = 1; i + 1 < pts.size(); ++i) {
                                double vol = signed_volume(pts[0], pts[i], pts[i + 1], fake_point);
                                total_volume += vol;
                                total_tetrahedra++;
                            }
                        }
                    }
                }
            }
        }

        std::cout << " Total tetrahedra: " << total_tetrahedra << std::endl;
        std::cout << " Computed volume for building " << id << ": " << std::abs(total_volume) << std::endl;

        j["CityObjects"][id]["attributes"]["volume"] = std::abs(total_volume);

        if (!roof_normals.empty()) {
            double avg_nx = 0, avg_ny = 0, avg_nz = 0;
            for (const auto& n : roof_normals) {
                avg_nx += n[0];
                avg_ny += n[1];
                avg_nz += n[2];
            }
            double len = std::sqrt(avg_nx * avg_nx + avg_ny * avg_ny + avg_nz * avg_nz);
            if (len > 0) {
                std::vector<double> avg_normal = {avg_nx / len, avg_ny / len, avg_nz / len};
                double azimuth = azimuth_from_normal(avg_normal);
                std::cout << " Roof azimuth: " << azimuth << " degrees from North" << std::endl;
                j["CityObjects"][id]["attributes"]["roof_azimuth_deg"] = azimuth;
            }
        }

        nobuildings++;
    }

    std::cout << "\nProcessed " << nobuildings << " buildings." << std::endl;
    std::cout << "Number of vertices: " << j["vertices"].size() << std::endl;

    // Write output file
    std::ofstream o("out.city.json");
    if (!o.is_open()) {
        std::cerr << "Error: Could not create output file" << std::endl;
        return 1;
    }

    o << j.dump(2) << std::endl;
    o.close();

    std::cout << "Output written to: out.city.json" << std::endl;

    return 0;
}
